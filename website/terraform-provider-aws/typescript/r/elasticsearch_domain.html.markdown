---
subcategory: "Elasticsearch"
layout: "aws"
page_title: "AWS: aws_elasticsearch_domain"
description: |-
  Terraform resource for managing an AWS Elasticsearch Domain.
---

# Resource: aws\_elasticsearch\_domain

Manages an AWS Elasticsearch Domain.

## Example Usage

### Basic Usage

```typescript
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as aws from "./.gen/providers/aws";
new aws.elasticsearchDomain.ElasticsearchDomain(this, "example", {
  clusterConfig: {
    instanceType: "r4.large.elasticsearch",
  },
  domainName: "example",
  elasticsearchVersion: "7.10",
  tags: {
    Domain: "TestDomain",
  },
});

```

### Access Policy

\-> See also: [`awsElasticsearchDomainPolicy` resource](/docs/providers/aws/r/elasticsearch_domain_policy.html)

```typescript
import * as cdktf from "cdktf";
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as aws from "./.gen/providers/aws";
/*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
You can read more about this at https://cdk.tf/variables*/
const domain = new cdktf.TerraformVariable(this, "domain", {
  default: "tf-test",
});
const dataAwsCallerIdentityCurrent =
  new aws.dataAwsCallerIdentity.DataAwsCallerIdentity(this, "current", {});
const dataAwsRegionCurrent = new aws.dataAwsRegion.DataAwsRegion(
  this,
  "current_2",
  {}
);
/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
dataAwsRegionCurrent.overrideLogicalId("current");
new aws.elasticsearchDomain.ElasticsearchDomain(this, "example", {
  accessPolicies: `{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Action": "es:*",
      "Principal": "*",
      "Effect": "Allow",
      "Resource": "arn:aws:es:\${${dataAwsRegionCurrent.name}}:\${${dataAwsCallerIdentityCurrent.accountId}}:domain/\${${domain.value}}/*",
      "Condition": {
        "IpAddress": {"aws:SourceIp": ["66.193.100.22/32"]}
      }
    }
  ]
}
`,
  domainName: domain.value,
});

```

### Log Publishing to CloudWatch Logs

```typescript
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as aws from "./.gen/providers/aws";
const awsCloudwatchLogGroupExample =
  new aws.cloudwatchLogGroup.CloudwatchLogGroup(this, "example", {
    name: "example",
  });
const awsCloudwatchLogResourcePolicyExample =
  new aws.cloudwatchLogResourcePolicy.CloudwatchLogResourcePolicy(
    this,
    "example_1",
    {
      policyDocument:
        '{\n  "Version": "2012-10-17",\n  "Statement": [\n    {\n      "Effect": "Allow",\n      "Principal": {\n        "Service": "es.amazonaws.com"\n      },\n      "Action": [\n        "logs:PutLogEvents",\n        "logs:PutLogEventsBatch",\n        "logs:CreateLogStream"\n      ],\n      "Resource": "arn:aws:logs:*"\n    }\n  ]\n}\n',
      policyName: "example",
    }
  );
/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
awsCloudwatchLogResourcePolicyExample.overrideLogicalId("example");
const awsElasticsearchDomainExample =
  new aws.elasticsearchDomain.ElasticsearchDomain(this, "example_2", {
    logPublishingOptions: [
      {
        cloudwatchLogGroupArn: awsCloudwatchLogGroupExample.arn,
        logType: "INDEX_SLOW_LOGS",
      },
    ],
  });
/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
awsElasticsearchDomainExample.overrideLogicalId("example");

```

### VPC based ES

```typescript
import * as cdktf from "cdktf";
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as aws from "./.gen/providers/aws";
/*Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
You can read more about this at https://cdk.tf/variables*/
const domain = new cdktf.TerraformVariable(this, "domain", {
  default: "tf-test",
});
const vpc = new cdktf.TerraformVariable(this, "vpc", {});
const awsIamServiceLinkedRoleEs =
  new aws.iamServiceLinkedRole.IamServiceLinkedRole(this, "es", {
    awsServiceName: "es.amazonaws.com",
  });
const dataAwsCallerIdentityCurrent =
  new aws.dataAwsCallerIdentity.DataAwsCallerIdentity(this, "current", {});
const dataAwsRegionCurrent = new aws.dataAwsRegion.DataAwsRegion(
  this,
  "current_4",
  {}
);
/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
dataAwsRegionCurrent.overrideLogicalId("current");
const dataAwsVpcSelected = new aws.dataAwsVpc.DataAwsVpc(this, "selected", {
  tags: {
    Name: vpc.value,
  },
});
const awsSecurityGroupEs = new aws.securityGroup.SecurityGroup(this, "es_6", {
  description: "Managed by Terraform",
  ingress: [
    {
      cidrBlocks: [dataAwsVpcSelected.cidrBlock],
      fromPort: 443,
      protocol: "tcp",
      toPort: 443,
    },
  ],
  name: `\${${vpc.value}}-elasticsearch-\${${domain.value}}`,
  vpcId: dataAwsVpcSelected.id,
});
/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
awsSecurityGroupEs.overrideLogicalId("es");
const dataAwsSubnetIdsSelected = new aws.dataAwsSubnetIds.DataAwsSubnetIds(
  this,
  "selected_7",
  {
    tags: {
      Tier: "private",
    },
    vpcId: dataAwsVpcSelected.id,
  }
);
/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
dataAwsSubnetIdsSelected.overrideLogicalId("selected");
const awsElasticsearchDomainEs =
  new aws.elasticsearchDomain.ElasticsearchDomain(this, "es_8", {
    accessPolicies: `{
	"Version": "2012-10-17",
	"Statement": [
		{
			"Action": "es:*",
			"Principal": "*",
			"Effect": "Allow",
			"Resource": "arn:aws:es:\${${dataAwsRegionCurrent.name}}:\${${dataAwsCallerIdentityCurrent.accountId}}:domain/\${${domain.value}}/*"
		}
	]
}
`,
    advancedOptions: {
      "rest.action.multi.allow_explicit_index": "true",
    },
    clusterConfig: {
      instanceType: "m4.large.elasticsearch",
      zoneAwarenessEnabled: true,
    },
    depends_on: [`\${${awsIamServiceLinkedRoleEs.fqn}}`],
    domainName: domain.value,
    elasticsearchVersion: "6.3",
    tags: {
      Domain: "TestDomain",
    },
    vpcOptions: {
      securityGroupIds: [awsSecurityGroupEs.id],
      subnetIds: [
        `\${${dataAwsSubnetIdsSelected.ids.fqn}[0]}`,
        `\${${dataAwsSubnetIdsSelected.ids.fqn}[1]}`,
      ],
    },
  });
/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
awsElasticsearchDomainEs.overrideLogicalId("es");

```

## Argument Reference

The following arguments are required:

* `domainName` - (Required) Name of the domain.

The following arguments are optional:

* `accessPolicies` - (Optional) IAM policy document specifying the access policies for the domain.
* `advancedOptions` - (Optional) Key-value string pairs to specify advanced configuration options. Note that the values for these configuration options must be strings (wrapped in quotes) or they may be wrong and cause a perpetual diff, causing Terraform to want to recreate your Elasticsearch domain on every apply.
* `advancedSecurityOptions` - (Optional) Configuration block for [fine-grained access control](https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/fgac.html). Detailed below.
* `autoTuneOptions` - (Optional) Configuration block for the Auto-Tune options of the domain. Detailed below.
* `clusterConfig` - (Optional) Configuration block for the cluster of the domain. Detailed below.
* `cognitoOptions` - (Optional) Configuration block for authenticating Kibana with Cognito. Detailed below.
* `domainEndpointOptions` - (Optional) Configuration block for domain endpoint HTTP(S) related options. Detailed below.
* `ebsOptions` - (Optional) Configuration block for EBS related options, may be required based on chosen [instance size](https://aws.amazon.com/elasticsearch-service/pricing/). Detailed below.
* `elasticsearchVersion` - (Optional) Version of Elasticsearch to deploy. Defaults to `15`.
* `encryptAtRest` - (Optional) Configuration block for encrypt at rest options. Only available for [certain instance types](http://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/aes-supported-instance-types.html). Detailed below.
* `logPublishingOptions` - (Optional) Configuration block for publishing slow and application logs to CloudWatch Logs. This block can be declared multiple times, for each log\_type, within the same resource. Detailed below.
* `nodeToNodeEncryption` - (Optional) Configuration block for node-to-node encryption options. Detailed below.
* `snapshotOptions` - (Optional) Configuration block for snapshot related options. Detailed below. DEPRECATED. For domains running Elasticsearch 5.3 and later, Amazon ES takes hourly automated snapshots, making this setting irrelevant. For domains running earlier versions of Elasticsearch, Amazon ES takes daily automated snapshots.
* `tags` - (Optional) Map of tags to assign to the resource. If configured with a provider [`defaultTags` configuration block](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#default_tags-configuration-block) present, tags with matching keys will overwrite those defined at the provider-level.
* `vpcOptions` - (Optional) Configuration block for VPC related options. Adding or removing this configuration forces a new resource ([documentation](https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-vpc.html#es-vpc-limitations)). Detailed below.

### advanced\_security\_options

* `enabled` - (Required, Forces new resource) Whether advanced security is enabled.
* `internalUserDatabaseEnabled` - (Optional, Default: false) Whether the internal user database is enabled. If not set, defaults to `false` by the AWS API.
* `masterUserOptions` - (Optional) Configuration block for the main user. Detailed below.

#### master\_user\_options

* `masterUserArn` - (Optional) ARN for the main user. Only specify if `internalUserDatabaseEnabled` is not set or set to `false`.
* `masterUserName` - (Optional) Main user's username, which is stored in the Amazon Elasticsearch Service domain's internal database. Only specify if `internalUserDatabaseEnabled` is set to `true`.
* `masterUserPassword` - (Optional) Main user's password, which is stored in the Amazon Elasticsearch Service domain's internal database. Only specify if `internalUserDatabaseEnabled` is set to `true`.

### auto\_tune\_options

* `desiredState` - (Required) The Auto-Tune desired state for the domain. Valid values: `enabled` or `disabled`.
* `maintenanceSchedule` - (Required if `rollbackOnDisable` is set to `defaultRollback`) Configuration block for Auto-Tune maintenance windows. Can be specified multiple times for each maintenance window. Detailed below.
* `rollbackOnDisable` - (Optional) Whether to roll back to default Auto-Tune settings when disabling Auto-Tune. Valid values: `defaultRollback` or `noRollback`.

#### maintenance\_schedule

* `startAt` - (Required) Date and time at which to start the Auto-Tune maintenance schedule in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
* `duration` - (Required) Configuration block for the duration of the Auto-Tune maintenance window. Detailed below.
* `cronExpressionForRecurrence` - (Required) A cron expression specifying the recurrence pattern for an Auto-Tune maintenance schedule.

##### duration

* `value` - (Required) An integer specifying the value of the duration of an Auto-Tune maintenance window.
* `unit` - (Required) The unit of time specifying the duration of an Auto-Tune maintenance window. Valid values: `hours`.

### cluster\_config

* `coldStorageOptions` - (Optional) Configuration block containing cold storage configuration. Detailed below.
* `dedicatedMasterCount` - (Optional) Number of dedicated main nodes in the cluster.
* `dedicatedMasterEnabled` - (Optional) Whether dedicated main nodes are enabled for the cluster.
* `dedicatedMasterType` - (Optional) Instance type of the dedicated main nodes in the cluster.
* `instanceCount` - (Optional) Number of instances in the cluster.
* `instanceType` - (Optional) Instance type of data nodes in the cluster.
* `warmCount` - (Optional) Number of warm nodes in the cluster. Valid values are between `2` and `150`. `warmCount` can be only and must be set when `warmEnabled` is set to `true`.
* `warmEnabled` - (Optional) Whether to enable warm storage.
* `warmType` - (Optional) Instance type for the Elasticsearch cluster's warm nodes. Valid values are `ultrawarm1MediumElasticsearch`, `ultrawarm1LargeElasticsearch` and `ultrawarm1XlargeElasticsearch`. `warmType` can be only and must be set when `warmEnabled` is set to `true`.
* `zoneAwarenessConfig` - (Optional) Configuration block containing zone awareness settings. Detailed below.
* `zoneAwarenessEnabled` - (Optional) Whether zone awareness is enabled, set to `true` for multi-az deployment. To enable awareness with three Availability Zones, the `availabilityZoneCount` within the `zoneAwarenessConfig` must be set to `3`.

#### cold\_storage\_options

* `enabled` - (Optional) Boolean to enable cold storage for an Elasticsearch domain. Defaults to `false`. Master and ultrawarm nodes must be enabled for cold storage.

#### zone\_awareness\_config

* `availabilityZoneCount` - (Optional) Number of Availability Zones for the domain to use with `zoneAwarenessEnabled`. Defaults to `2`. Valid values: `2` or `3`.

### cognito\_options

AWS documentation: [Amazon Cognito Authentication for Kibana](https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-cognito-auth.html)

* `enabled` - (Optional, Default: false) Whether Amazon Cognito authentication with Kibana is enabled or not.
* `identityPoolId` - (Required) ID of the Cognito Identity Pool to use.
* `roleArn` - (Required) ARN of the IAM role that has the AmazonESCognitoAccess policy attached.
* `userPoolId` - (Required) ID of the Cognito User Pool to use.

### domain\_endpoint\_options

* `customEndpointCertificateArn` - (Optional) ACM certificate ARN for your custom endpoint.
* `customEndpointEnabled` - (Optional) Whether to enable custom endpoint for the Elasticsearch domain.
* `customEndpoint` - (Optional) Fully qualified domain for your custom endpoint.
* `enforceHttps` - (Optional) Whether or not to require HTTPS. Defaults to `true`.
* `tlsSecurityPolicy` - (Optional) Name of the TLS security policy that needs to be applied to the HTTPS endpoint. Valid values:  `policyMinTls10201907` and `policyMinTls12201907`. Terraform will only perform drift detection if a configuration value is provided.

### ebs\_options

* `ebsEnabled` - (Required) Whether EBS volumes are attached to data nodes in the domain.
* `iops` - (Optional) Baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the GP3 and Provisioned IOPS EBS volume types.
* `throughput` - (Required if `volumeType` is set to `gp3`) Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the gp3 volume type. Valid values are between `125` and `1000`.
* `volumeSize` - (Required if `ebsEnabled` is set to `true`.) Size of EBS volumes attached to data nodes (in GiB).
* `volumeType` - (Optional) Type of EBS volumes attached to data nodes.

### encrypt\_at\_rest

\~> **Note:** You can enable `encryptAtRest` *in place* for an existing, unencrypted domain only if your Elasticsearch version is 6.7 or greater. For lower versions, if you enable `encryptAtRest`, Terraform with recreate the domain, potentially causing data loss. For any version, if you disable `encryptAtRest` for an existing, encrypted domain, Terraform will recreate the domain, potentially causing data loss. If you change the `kmsKeyId`, Terraform will also recreate the domain, potentially causing data loss.

* `enabled` - (Required) Whether to enable encryption at rest. If the `encryptAtRest` block is not provided then this defaults to `false`. Enabling encryption on new domains requires `elasticsearchVersion` 5.1 or greater.
* `kmsKeyId` - (Optional) KMS key ARN to encrypt the Elasticsearch domain with. If not specified then it defaults to using the `aws/es` service KMS key. Note that KMS will accept a KMS key ID but will return the key ARN. To prevent Terraform detecting unwanted changes, use the key ARN instead.

### log\_publishing\_options

* `cloudwatchLogGroupArn` - (Required) ARN of the Cloudwatch log group to which log needs to be published.
* `enabled` - (Optional, Default: true) Whether given log publishing option is enabled or not.
* `logType` - (Required) Type of Elasticsearch log. Valid values: `indexSlowLogs`, `searchSlowLogs`, `esApplicationLogs`, `auditLogs`.

### node\_to\_node\_encryption

\~> **Note:** You can enable `nodeToNodeEncryption` *in place* for an existing, unencrypted domain only if your Elasticsearch version is 6.7 or greater. For lower versions, if you enable `nodeToNodeEncryption`, Terraform will recreate the domain, potentially causing data loss. For any version, if you disable `nodeToNodeEncryption` for an existing, node-to-node encrypted domain, Terraform will recreate the domain, potentially causing data loss.

* `enabled` - (Required) Whether to enable node-to-node encryption. If the `nodeToNodeEncryption` block is not provided then this defaults to `false`. Enabling node-to-node encryption of a new domain requires an `elasticsearchVersion` of `60` or greater.

### snapshot\_options

* `automatedSnapshotStartHour` - (Required) Hour during which the service takes an automated daily snapshot of the indices in the domain.

### vpc\_options

AWS documentation: [VPC Support for Amazon Elasticsearch Service Domains](https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-vpc.html)

\~> **Note:** You must have created the service linked role for the Elasticsearch service to use `vpcOptions`. If you need to create the service linked role at the same time as the Elasticsearch domain then you must use `dependsOn` to make sure that the role is created before the Elasticsearch domain. See the [VPC based ES domain example](#vpc-based-es) above.

\-> Security Groups and Subnets referenced in these attributes must all be within the same VPC. This determines what VPC the endpoints are created in.

* `securityGroupIds` - (Optional) List of VPC Security Group IDs to be applied to the Elasticsearch domain endpoints. If omitted, the default Security Group for the VPC will be used.
* `subnetIds` - (Required) List of VPC Subnet IDs for the Elasticsearch domain endpoints to be created in.

## Attributes Reference

In addition to all arguments above, the following attributes are exported:

* `arn` - ARN of the domain.
* `domainId` - Unique identifier for the domain.
* `domainName` - Name of the Elasticsearch domain.
* `endpoint` - Domain-specific endpoint used to submit index, search, and data upload requests.
* `kibanaEndpoint` - Domain-specific endpoint for kibana without https scheme.
* `tagsAll` - Map of tags assigned to the resource, including those inherited from the provider [`defaultTags` configuration block](https://registry.terraform.io/providers/hashicorp/aws/latest/docs#default_tags-configuration-block).
* `vpcOptions0AvailabilityZones` - If the domain was created inside a VPC, the names of the availability zones the configured `subnetIds` were created inside.
* `vpcOptions0VpcId` - If the domain was created inside a VPC, the ID of the VPC.

## Timeouts

[Configuration options](https://developer.hashicorp.com/terraform/language/resources/syntax#operation-timeouts):

* `create` - (Default `60M`)
* `update` - (Default `60M`)
* `delete` - (Default `90M`)

## Import

Elasticsearch domains can be imported using the `domainName`, e.g.,

```console
$ terraform import aws_elasticsearch_domain.example domain_name
```
