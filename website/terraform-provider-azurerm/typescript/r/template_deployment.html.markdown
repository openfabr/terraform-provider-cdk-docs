---
subcategory: "Template"
layout: "azurerm"
page_title: "Azure Resource Manager: azurerm_template_deployment"
description: |-
  Manages a template deployment of resources.
---

# azurerm\_template\_deployment

Manages a template deployment of resources

\~> **Note:** The `azurermTemplateDeployment` resource has been superseded by the [`azurermResourceGroupTemplateDeployment`](resource_group_template_deployment.html) resource. The existing `azurermTemplateDeployment` resource will be deprecated (but still available) in version 3.0 of the AzureRM Terraform Provider - we recommend using the `azurermResourceGroupTemplateDeployment` resource for new deployments.

\-> **Note:** This resource will not clean up nested resources deployed by the ARM Template Deployment. We recommend using the [`azurermResourceGroupTemplateDeployment`](resource_group_template_deployment.html) resource for new deployments, which can do this.

## Example Usage

\~> **Note:** This example uses [Storage Accounts](storage_account.html) and [Public IP's](public_ip.html) which are natively supported by Terraform - we'd highly recommend using the Native Resources where possible instead rather than an ARM Template, for the reasons outlined above.

```typescript
import * as cdktf from "cdktf";
/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as azurerm from "./.gen/providers/azurerm";
/*The following providers are missing schema information and might need manual adjustments to synthesize correctly: azurerm.
For a more precise conversion please use the --provider flag in convert.*/
const azurermResourceGroupExample = new azurerm.resourceGroup.ResourceGroup(
  this,
  "example",
  {
    location: "West Europe",
    name: "example-resources",
  }
);
const azurermTemplateDeploymentExample =
  new azurerm.templateDeployment.TemplateDeployment(this, "example_1", {
    deployment_mode: "Incremental",
    name: "acctesttemplate-01",
    parameters: [
      {
        storageAccountType: "Standard_GRS",
      },
    ],
    resource_group_name: azurermResourceGroupExample.name,
    template_body:
      '{\n  "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",\n  "contentVersion": "1.0.0.0",\n  "parameters": {\n    "storageAccountType": {\n      "type": "string",\n      "defaultValue": "Standard_LRS",\n      "allowedValues": [\n        "Standard_LRS",\n        "Standard_GRS",\n        "Standard_ZRS"\n      ],\n      "metadata": {\n        "description": "Storage Account type"\n      }\n    }\n  },\n  "variables": {\n    "location": "[resourceGroup().location]",\n    "storageAccountName": "[concat(uniquestring(resourceGroup().id), \'storage\')]",\n    "publicIPAddressName": "[concat(\'myPublicIp\', uniquestring(resourceGroup().id))]",\n    "publicIPAddressType": "Dynamic",\n    "apiVersion": "2015-06-15",\n    "dnsLabelPrefix": "terraform-acctest"\n  },\n  "resources": [\n    {\n      "type": "Microsoft.Storage/storageAccounts",\n      "name": "[variables(\'storageAccountName\')]",\n      "apiVersion": "[variables(\'apiVersion\')]",\n      "location": "[variables(\'location\')]",\n      "properties": {\n        "accountType": "[parameters(\'storageAccountType\')]"\n      }\n    },\n    {\n      "type": "Microsoft.Network/publicIPAddresses",\n      "apiVersion": "[variables(\'apiVersion\')]",\n      "name": "[variables(\'publicIPAddressName\')]",\n      "location": "[variables(\'location\')]",\n      "properties": {\n        "publicIPAllocationMethod": "[variables(\'publicIPAddressType\')]",\n        "dnsSettings": {\n          "domainNameLabel": "[variables(\'dnsLabelPrefix\')]"\n        }\n      }\n    }\n  ],\n  "outputs": {\n    "storageAccountName": {\n      "type": "string",\n      "value": "[variables(\'storageAccountName\')]"\n    }\n  }\n}\n',
  });
/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
azurermTemplateDeploymentExample.overrideLogicalId("example");
new cdktf.TerraformOutput(this, "storageAccountName", {
  value: `\${${azurermTemplateDeploymentExample.outputs.fqn}["storageAccountName"]}`,
});

```

## Argument Reference

The following arguments are supported:

* `name` - (Required) Specifies the name of the template deployment. Changing this forces a new resource to be created.
* `resourceGroupName` - (Required) The name of the resource group in which to create the template deployment. Changing this forces a new resource to be created.
* `deploymentMode` - (Required) Specifies the mode that is used to deploy resources. This value could be either `incremental` or `complete`.
  Note that you will almost *always* want this to be set to `incremental` otherwise the deployment will destroy all infrastructure not
  specified within the template, and Terraform will not be aware of this.
* `templateBody` - (Optional) Specifies the JSON definition for the template.

\~> **Note:** There's a [`file` function available](https://www.terraform.io/docs/configuration/functions/file.html) which allows you to read this from an external file, which helps makes this more resource more readable.

*   `parameters` - (Optional) Specifies the name and value pairs that define the deployment parameters for the template.

*   `parametersBody` - (Optional) Specifies a valid Azure JSON parameters file that define the deployment parameters. It can contain KeyVault references

\~> **Note:** There's a [`file` function available](https://www.terraform.io/docs/configuration/functions/file.html) which allows you to read this from an external file, which helps makes this more resource more readable.

\~> **Also Note:** This is NOT an Azure deployment parameters file, as defined in the [`microsoftSchema's`](https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#). It is effectively the object supplied to the "parameters" attribute in that schema. If you are providing, or generating via [`templateFile`](https://www.terraform.io/docs/providers/template/d/file.html), this argument, do not provide a full deployment parameters JSON file with "$schema" and "contentVersion" attributes, just provide the object for the "parameters" attribute of that schema.

## Attributes Reference

The following attributes are exported:

*   `id` - The Template Deployment ID.

*   `outputs` - A map of supported scalar output types returned from the deployment (currently, Azure Template Deployment outputs of type String, Int and Bool are supported, and are converted to strings - others will be ignored) and can be accessed using `outputs["name"]`.

## Note

Terraform does not know about the individual resources created by Azure using a deployment template and therefore cannot delete these resources during a destroy. Destroying a template deployment removes the associated deployment operations, but will not delete the Azure resources created by the deployment. In order to delete these resources, the containing resource group must also be destroyed. [More information](https://docs.microsoft.com/rest/api/resources/deployments#Deployments_Delete).

## Timeouts

The `timeouts` block allows you to specify [timeouts](https://www.terraform.io/language/resources/syntax#operation-timeouts) for certain actions:

* `create` - (Defaults to 3 hours) Used when creating the Template Deployment.
* `update` - (Defaults to 3 hours) Used when updating the Template Deployment.
* `read` - (Defaults to 5 minutes) Used when retrieving the Template Deployment.
* `delete` - (Defaults to 3 hours) Used when deleting the Template Deployment.
